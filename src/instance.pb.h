// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: instance.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_instance_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_instance_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "conf.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_instance_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_instance_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_instance_2eproto;
namespace epxos_instance_proto {
class EpDepsIds;
struct EpDepsIdsDefaultTypeInternal;
extern EpDepsIdsDefaultTypeInternal _EpDepsIds_default_instance_;
class EpIns;
struct EpInsDefaultTypeInternal;
extern EpInsDefaultTypeInternal _EpIns_default_instance_;
class EpInstID;
struct EpInstIDDefaultTypeInternal;
extern EpInstIDDefaultTypeInternal _EpInstID_default_instance_;
class EpInstance;
struct EpInstanceDefaultTypeInternal;
extern EpInstanceDefaultTypeInternal _EpInstance_default_instance_;
class EpKeyValueItem;
struct EpKeyValueItemDefaultTypeInternal;
extern EpKeyValueItemDefaultTypeInternal _EpKeyValueItem_default_instance_;
class EpValueItem;
struct EpValueItemDefaultTypeInternal;
extern EpValueItemDefaultTypeInternal _EpValueItem_default_instance_;
class EpValueStorageBody;
struct EpValueStorageBodyDefaultTypeInternal;
extern EpValueStorageBodyDefaultTypeInternal _EpValueStorageBody_default_instance_;
class EpaxosInsReadReq;
struct EpaxosInsReadReqDefaultTypeInternal;
extern EpaxosInsReadReqDefaultTypeInternal _EpaxosInsReadReq_default_instance_;
class EpaxosInsReadRsp;
struct EpaxosInsReadRspDefaultTypeInternal;
extern EpaxosInsReadRspDefaultTypeInternal _EpaxosInsReadRsp_default_instance_;
class EpaxosInsWriteReq;
struct EpaxosInsWriteReqDefaultTypeInternal;
extern EpaxosInsWriteReqDefaultTypeInternal _EpaxosInsWriteReq_default_instance_;
class EpaxosInsWriteRsp;
struct EpaxosInsWriteRspDefaultTypeInternal;
extern EpaxosInsWriteRspDefaultTypeInternal _EpaxosInsWriteRsp_default_instance_;
class InstanceSwapMsg;
struct InstanceSwapMsgDefaultTypeInternal;
extern InstanceSwapMsgDefaultTypeInternal _InstanceSwapMsg_default_instance_;
}  // namespace epxos_instance_proto
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace epxos_instance_proto {
enum EpWorkState : int {
  EPXOS_EM_WK_EMPTY = 0,
  EPXOS_EM_WK_PROPOSE = 1,
  EPXOS_EM_WK_PREACCEPT = 2,
  EPXOS_EM_WK_ACCEPT = 3,
  EPXOS_EM_WK_COMMIT = 4,
  EPXOS_EM_WK_EXEC = 5,
  EpWorkState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EpWorkState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EpWorkState_IsValid(int value);
constexpr EpWorkState EpWorkState_MIN = static_cast<EpWorkState>(0);
constexpr EpWorkState EpWorkState_MAX = static_cast<EpWorkState>(5);
constexpr int EpWorkState_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
EpWorkState_descriptor();
template <typename T>
const std::string& EpWorkState_Name(T value) {
  static_assert(std::is_same<T, EpWorkState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EpWorkState_Name().");
  return EpWorkState_Name(static_cast<EpWorkState>(value));
}
template <>
inline const std::string& EpWorkState_Name(EpWorkState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EpWorkState_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool EpWorkState_Parse(absl::string_view name, EpWorkState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EpWorkState>(
      EpWorkState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class EpIns final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpIns) */ {
 public:
  inline EpIns() : EpIns(nullptr) {}
  ~EpIns() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpIns(::google::protobuf::internal::ConstantInitialized);

  EpIns(const EpIns& from);
  EpIns(EpIns&& from) noexcept
    : EpIns() {
    *this = ::std::move(from);
  }

  inline EpIns& operator=(const EpIns& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpIns& operator=(EpIns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpIns& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpIns* internal_default_instance() {
    return reinterpret_cast<const EpIns*>(
               &_EpIns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EpIns& a, EpIns& b) {
    a.Swap(&b);
  }
  inline void Swap(EpIns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpIns* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpIns* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpIns>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpIns& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpIns& from) {
    EpIns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpIns* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpIns";
  }
  protected:
  explicit EpIns(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeidFieldNumber = 3,
    kInsidFieldNumber = 2,
  };
  // .epxos_instance_proto.EpNodeId nodeid = 3;
  bool has_nodeid() const;
  void clear_nodeid() ;
  const ::epxos_instance_proto::EpNodeId& nodeid() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpNodeId* release_nodeid();
  ::epxos_instance_proto::EpNodeId* mutable_nodeid();
  void set_allocated_nodeid(::epxos_instance_proto::EpNodeId* value);
  void unsafe_arena_set_allocated_nodeid(::epxos_instance_proto::EpNodeId* value);
  ::epxos_instance_proto::EpNodeId* unsafe_arena_release_nodeid();

  private:
  const ::epxos_instance_proto::EpNodeId& _internal_nodeid() const;
  ::epxos_instance_proto::EpNodeId* _internal_mutable_nodeid();

  public:
  // uint64 insid = 2;
  void clear_insid() ;
  ::uint64_t insid() const;
  void set_insid(::uint64_t value);

  private:
  ::uint64_t _internal_insid() const;
  void _internal_set_insid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpIns)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::epxos_instance_proto::EpNodeId* nodeid_;
    ::uint64_t insid_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class EpInstID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpInstID) */ {
 public:
  inline EpInstID() : EpInstID(nullptr) {}
  ~EpInstID() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpInstID(::google::protobuf::internal::ConstantInitialized);

  EpInstID(const EpInstID& from);
  EpInstID(EpInstID&& from) noexcept
    : EpInstID() {
    *this = ::std::move(from);
  }

  inline EpInstID& operator=(const EpInstID& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpInstID& operator=(EpInstID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpInstID& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpInstID* internal_default_instance() {
    return reinterpret_cast<const EpInstID*>(
               &_EpInstID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EpInstID& a, EpInstID& b) {
    a.Swap(&b);
  }
  inline void Swap(EpInstID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpInstID* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpInstID* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpInstID>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpInstID& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpInstID& from) {
    EpInstID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpInstID* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpInstID";
  }
  protected:
  explicit EpInstID(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIIDFieldNumber = 2,
    kSeqidFieldNumber = 1,
  };
  // .epxos_instance_proto.EpIns iID = 2;
  bool has_iid() const;
  void clear_iid() ;
  const ::epxos_instance_proto::EpIns& iid() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpIns* release_iid();
  ::epxos_instance_proto::EpIns* mutable_iid();
  void set_allocated_iid(::epxos_instance_proto::EpIns* value);
  void unsafe_arena_set_allocated_iid(::epxos_instance_proto::EpIns* value);
  ::epxos_instance_proto::EpIns* unsafe_arena_release_iid();

  private:
  const ::epxos_instance_proto::EpIns& _internal_iid() const;
  ::epxos_instance_proto::EpIns* _internal_mutable_iid();

  public:
  // uint64 seqid = 1;
  void clear_seqid() ;
  ::uint64_t seqid() const;
  void set_seqid(::uint64_t value);

  private:
  ::uint64_t _internal_seqid() const;
  void _internal_set_seqid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpInstID)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::epxos_instance_proto::EpIns* iid_;
    ::uint64_t seqid_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class EpDepsIds final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpDepsIds) */ {
 public:
  inline EpDepsIds() : EpDepsIds(nullptr) {}
  ~EpDepsIds() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpDepsIds(::google::protobuf::internal::ConstantInitialized);

  EpDepsIds(const EpDepsIds& from);
  EpDepsIds(EpDepsIds&& from) noexcept
    : EpDepsIds() {
    *this = ::std::move(from);
  }

  inline EpDepsIds& operator=(const EpDepsIds& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpDepsIds& operator=(EpDepsIds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpDepsIds& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpDepsIds* internal_default_instance() {
    return reinterpret_cast<const EpDepsIds*>(
               &_EpDepsIds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EpDepsIds& a, EpDepsIds& b) {
    a.Swap(&b);
  }
  inline void Swap(EpDepsIds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpDepsIds* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpDepsIds* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpDepsIds>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpDepsIds& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpDepsIds& from) {
    EpDepsIds::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpDepsIds* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpDepsIds";
  }
  protected:
  explicit EpDepsIds(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrdpsFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // repeated .epxos_instance_proto.EpInstID arrdps = 1;
  int arrdps_size() const;
  private:
  int _internal_arrdps_size() const;

  public:
  void clear_arrdps() ;
  ::epxos_instance_proto::EpInstID* mutable_arrdps(int index);
  ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpInstID >*
      mutable_arrdps();
  private:
  const ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpInstID>& _internal_arrdps() const;
  ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpInstID>* _internal_mutable_arrdps();
  public:
  const ::epxos_instance_proto::EpInstID& arrdps(int index) const;
  ::epxos_instance_proto::EpInstID* add_arrdps();
  const ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpInstID >&
      arrdps() const;
  // uint32 version = 2;
  void clear_version() ;
  ::uint32_t version() const;
  void set_version(::uint32_t value);

  private:
  ::uint32_t _internal_version() const;
  void _internal_set_version(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpDepsIds)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpInstID > arrdps_;
    ::uint32_t version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class EpKeyValueItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpKeyValueItem) */ {
 public:
  inline EpKeyValueItem() : EpKeyValueItem(nullptr) {}
  ~EpKeyValueItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpKeyValueItem(::google::protobuf::internal::ConstantInitialized);

  EpKeyValueItem(const EpKeyValueItem& from);
  EpKeyValueItem(EpKeyValueItem&& from) noexcept
    : EpKeyValueItem() {
    *this = ::std::move(from);
  }

  inline EpKeyValueItem& operator=(const EpKeyValueItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpKeyValueItem& operator=(EpKeyValueItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpKeyValueItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpKeyValueItem* internal_default_instance() {
    return reinterpret_cast<const EpKeyValueItem*>(
               &_EpKeyValueItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EpKeyValueItem& a, EpKeyValueItem& b) {
    a.Swap(&b);
  }
  inline void Swap(EpKeyValueItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpKeyValueItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpKeyValueItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpKeyValueItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpKeyValueItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpKeyValueItem& from) {
    EpKeyValueItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpKeyValueItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpKeyValueItem";
  }
  protected:
  explicit EpKeyValueItem(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // optional string value = 2;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpKeyValueItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      52, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class EpInstance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpInstance) */ {
 public:
  inline EpInstance() : EpInstance(nullptr) {}
  ~EpInstance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpInstance(::google::protobuf::internal::ConstantInitialized);

  EpInstance(const EpInstance& from);
  EpInstance(EpInstance&& from) noexcept
    : EpInstance() {
    *this = ::std::move(from);
  }

  inline EpInstance& operator=(const EpInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpInstance& operator=(EpInstance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpInstance& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpInstance* internal_default_instance() {
    return reinterpret_cast<const EpInstance*>(
               &_EpInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EpInstance& a, EpInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(EpInstance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpInstance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpInstance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpInstance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpInstance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpInstance& from) {
    EpInstance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpInstance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpInstance";
  }
  protected:
  explicit EpInstance(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 6,
    kIIDFieldNumber = 1,
    kArryidsFieldNumber = 4,
    kSateFieldNumber = 2,
    kBallotNumFieldNumber = 3,
    kAckNumFieldNumber = 5,
  };
  // repeated .epxos_instance_proto.EpKeyValueItem kvs = 6;
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;

  public:
  void clear_kvs() ;
  ::epxos_instance_proto::EpKeyValueItem* mutable_kvs(int index);
  ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >*
      mutable_kvs();
  private:
  const ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>& _internal_kvs() const;
  ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>* _internal_mutable_kvs();
  public:
  const ::epxos_instance_proto::EpKeyValueItem& kvs(int index) const;
  ::epxos_instance_proto::EpKeyValueItem* add_kvs();
  const ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >&
      kvs() const;
  // .epxos_instance_proto.EpInstID iID = 1;
  bool has_iid() const;
  void clear_iid() ;
  const ::epxos_instance_proto::EpInstID& iid() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpInstID* release_iid();
  ::epxos_instance_proto::EpInstID* mutable_iid();
  void set_allocated_iid(::epxos_instance_proto::EpInstID* value);
  void unsafe_arena_set_allocated_iid(::epxos_instance_proto::EpInstID* value);
  ::epxos_instance_proto::EpInstID* unsafe_arena_release_iid();

  private:
  const ::epxos_instance_proto::EpInstID& _internal_iid() const;
  ::epxos_instance_proto::EpInstID* _internal_mutable_iid();

  public:
  // optional .epxos_instance_proto.EpDepsIds arryids = 4;
  bool has_arryids() const;
  void clear_arryids() ;
  const ::epxos_instance_proto::EpDepsIds& arryids() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpDepsIds* release_arryids();
  ::epxos_instance_proto::EpDepsIds* mutable_arryids();
  void set_allocated_arryids(::epxos_instance_proto::EpDepsIds* value);
  void unsafe_arena_set_allocated_arryids(::epxos_instance_proto::EpDepsIds* value);
  ::epxos_instance_proto::EpDepsIds* unsafe_arena_release_arryids();

  private:
  const ::epxos_instance_proto::EpDepsIds& _internal_arryids() const;
  ::epxos_instance_proto::EpDepsIds* _internal_mutable_arryids();

  public:
  // .epxos_instance_proto.EpWorkState sate = 2;
  void clear_sate() ;
  ::epxos_instance_proto::EpWorkState sate() const;
  void set_sate(::epxos_instance_proto::EpWorkState value);

  private:
  ::epxos_instance_proto::EpWorkState _internal_sate() const;
  void _internal_set_sate(::epxos_instance_proto::EpWorkState value);

  public:
  // uint32 ballot_num = 3;
  void clear_ballot_num() ;
  ::uint32_t ballot_num() const;
  void set_ballot_num(::uint32_t value);

  private:
  ::uint32_t _internal_ballot_num() const;
  void _internal_set_ballot_num(::uint32_t value);

  public:
  // uint32 ack_num = 5;
  void clear_ack_num() ;
  ::uint32_t ack_num() const;
  void set_ack_num(::uint32_t value);

  private:
  ::uint32_t _internal_ack_num() const;
  void _internal_set_ack_num(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpInstance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem > kvs_;
    ::epxos_instance_proto::EpInstID* iid_;
    ::epxos_instance_proto::EpDepsIds* arryids_;
    int sate_;
    ::uint32_t ballot_num_;
    ::uint32_t ack_num_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class EpValueItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpValueItem) */ {
 public:
  inline EpValueItem() : EpValueItem(nullptr) {}
  ~EpValueItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpValueItem(::google::protobuf::internal::ConstantInitialized);

  EpValueItem(const EpValueItem& from);
  EpValueItem(EpValueItem&& from) noexcept
    : EpValueItem() {
    *this = ::std::move(from);
  }

  inline EpValueItem& operator=(const EpValueItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpValueItem& operator=(EpValueItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpValueItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpValueItem* internal_default_instance() {
    return reinterpret_cast<const EpValueItem*>(
               &_EpValueItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EpValueItem& a, EpValueItem& b) {
    a.Swap(&b);
  }
  inline void Swap(EpValueItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpValueItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpValueItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpValueItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpValueItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpValueItem& from) {
    EpValueItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpValueItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpValueItem";
  }
  protected:
  explicit EpValueItem(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kIIDFieldNumber = 2,
  };
  // optional string value = 1;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .epxos_instance_proto.EpInstID iID = 2;
  bool has_iid() const;
  void clear_iid() ;
  const ::epxos_instance_proto::EpInstID& iid() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpInstID* release_iid();
  ::epxos_instance_proto::EpInstID* mutable_iid();
  void set_allocated_iid(::epxos_instance_proto::EpInstID* value);
  void unsafe_arena_set_allocated_iid(::epxos_instance_proto::EpInstID* value);
  ::epxos_instance_proto::EpInstID* unsafe_arena_release_iid();

  private:
  const ::epxos_instance_proto::EpInstID& _internal_iid() const;
  ::epxos_instance_proto::EpInstID* _internal_mutable_iid();

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpValueItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      46, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::epxos_instance_proto::EpInstID* iid_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class EpValueStorageBody final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpValueStorageBody) */ {
 public:
  inline EpValueStorageBody() : EpValueStorageBody(nullptr) {}
  ~EpValueStorageBody() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpValueStorageBody(::google::protobuf::internal::ConstantInitialized);

  EpValueStorageBody(const EpValueStorageBody& from);
  EpValueStorageBody(EpValueStorageBody&& from) noexcept
    : EpValueStorageBody() {
    *this = ::std::move(from);
  }

  inline EpValueStorageBody& operator=(const EpValueStorageBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpValueStorageBody& operator=(EpValueStorageBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpValueStorageBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpValueStorageBody* internal_default_instance() {
    return reinterpret_cast<const EpValueStorageBody*>(
               &_EpValueStorageBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EpValueStorageBody& a, EpValueStorageBody& b) {
    a.Swap(&b);
  }
  inline void Swap(EpValueStorageBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpValueStorageBody* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpValueStorageBody* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpValueStorageBody>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpValueStorageBody& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpValueStorageBody& from) {
    EpValueStorageBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpValueStorageBody* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpValueStorageBody";
  }
  protected:
  explicit EpValueStorageBody(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // optional .epxos_instance_proto.EpValueItem items = 1;
  bool has_items() const;
  void clear_items() ;
  const ::epxos_instance_proto::EpValueItem& items() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpValueItem* release_items();
  ::epxos_instance_proto::EpValueItem* mutable_items();
  void set_allocated_items(::epxos_instance_proto::EpValueItem* value);
  void unsafe_arena_set_allocated_items(::epxos_instance_proto::EpValueItem* value);
  ::epxos_instance_proto::EpValueItem* unsafe_arena_release_items();

  private:
  const ::epxos_instance_proto::EpValueItem& _internal_items() const;
  ::epxos_instance_proto::EpValueItem* _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpValueStorageBody)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::epxos_instance_proto::EpValueItem* items_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class InstanceSwapMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.InstanceSwapMsg) */ {
 public:
  inline InstanceSwapMsg() : InstanceSwapMsg(nullptr) {}
  ~InstanceSwapMsg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InstanceSwapMsg(::google::protobuf::internal::ConstantInitialized);

  InstanceSwapMsg(const InstanceSwapMsg& from);
  InstanceSwapMsg(InstanceSwapMsg&& from) noexcept
    : InstanceSwapMsg() {
    *this = ::std::move(from);
  }

  inline InstanceSwapMsg& operator=(const InstanceSwapMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceSwapMsg& operator=(InstanceSwapMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceSwapMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceSwapMsg* internal_default_instance() {
    return reinterpret_cast<const InstanceSwapMsg*>(
               &_InstanceSwapMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InstanceSwapMsg& a, InstanceSwapMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceSwapMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceSwapMsg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstanceSwapMsg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstanceSwapMsg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstanceSwapMsg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InstanceSwapMsg& from) {
    InstanceSwapMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceSwapMsg* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.InstanceSwapMsg";
  }
  protected:
  explicit InstanceSwapMsg(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInscFieldNumber = 1,
    kToNodeFieldNumber = 2,
    kFromNodeFieldNumber = 3,
  };
  // .epxos_instance_proto.EpInstance insc = 1;
  bool has_insc() const;
  void clear_insc() ;
  const ::epxos_instance_proto::EpInstance& insc() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpInstance* release_insc();
  ::epxos_instance_proto::EpInstance* mutable_insc();
  void set_allocated_insc(::epxos_instance_proto::EpInstance* value);
  void unsafe_arena_set_allocated_insc(::epxos_instance_proto::EpInstance* value);
  ::epxos_instance_proto::EpInstance* unsafe_arena_release_insc();

  private:
  const ::epxos_instance_proto::EpInstance& _internal_insc() const;
  ::epxos_instance_proto::EpInstance* _internal_mutable_insc();

  public:
  // .epxos_instance_proto.EpNodeId to_node = 2;
  bool has_to_node() const;
  void clear_to_node() ;
  const ::epxos_instance_proto::EpNodeId& to_node() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpNodeId* release_to_node();
  ::epxos_instance_proto::EpNodeId* mutable_to_node();
  void set_allocated_to_node(::epxos_instance_proto::EpNodeId* value);
  void unsafe_arena_set_allocated_to_node(::epxos_instance_proto::EpNodeId* value);
  ::epxos_instance_proto::EpNodeId* unsafe_arena_release_to_node();

  private:
  const ::epxos_instance_proto::EpNodeId& _internal_to_node() const;
  ::epxos_instance_proto::EpNodeId* _internal_mutable_to_node();

  public:
  // .epxos_instance_proto.EpNodeId from_node = 3;
  bool has_from_node() const;
  void clear_from_node() ;
  const ::epxos_instance_proto::EpNodeId& from_node() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpNodeId* release_from_node();
  ::epxos_instance_proto::EpNodeId* mutable_from_node();
  void set_allocated_from_node(::epxos_instance_proto::EpNodeId* value);
  void unsafe_arena_set_allocated_from_node(::epxos_instance_proto::EpNodeId* value);
  ::epxos_instance_proto::EpNodeId* unsafe_arena_release_from_node();

  private:
  const ::epxos_instance_proto::EpNodeId& _internal_from_node() const;
  ::epxos_instance_proto::EpNodeId* _internal_mutable_from_node();

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.InstanceSwapMsg)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::epxos_instance_proto::EpInstance* insc_;
    ::epxos_instance_proto::EpNodeId* to_node_;
    ::epxos_instance_proto::EpNodeId* from_node_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class EpaxosInsWriteReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpaxosInsWriteReq) */ {
 public:
  inline EpaxosInsWriteReq() : EpaxosInsWriteReq(nullptr) {}
  ~EpaxosInsWriteReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpaxosInsWriteReq(::google::protobuf::internal::ConstantInitialized);

  EpaxosInsWriteReq(const EpaxosInsWriteReq& from);
  EpaxosInsWriteReq(EpaxosInsWriteReq&& from) noexcept
    : EpaxosInsWriteReq() {
    *this = ::std::move(from);
  }

  inline EpaxosInsWriteReq& operator=(const EpaxosInsWriteReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpaxosInsWriteReq& operator=(EpaxosInsWriteReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpaxosInsWriteReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpaxosInsWriteReq* internal_default_instance() {
    return reinterpret_cast<const EpaxosInsWriteReq*>(
               &_EpaxosInsWriteReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EpaxosInsWriteReq& a, EpaxosInsWriteReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EpaxosInsWriteReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpaxosInsWriteReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpaxosInsWriteReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpaxosInsWriteReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpaxosInsWriteReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpaxosInsWriteReq& from) {
    EpaxosInsWriteReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpaxosInsWriteReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpaxosInsWriteReq";
  }
  protected:
  explicit EpaxosInsWriteReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 1,
  };
  // repeated .epxos_instance_proto.EpKeyValueItem list = 1;
  int list_size() const;
  private:
  int _internal_list_size() const;

  public:
  void clear_list() ;
  ::epxos_instance_proto::EpKeyValueItem* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >*
      mutable_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>& _internal_list() const;
  ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>* _internal_mutable_list();
  public:
  const ::epxos_instance_proto::EpKeyValueItem& list(int index) const;
  ::epxos_instance_proto::EpKeyValueItem* add_list();
  const ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >&
      list() const;
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpaxosInsWriteReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem > list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class EpaxosInsWriteRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpaxosInsWriteRsp) */ {
 public:
  inline EpaxosInsWriteRsp() : EpaxosInsWriteRsp(nullptr) {}
  ~EpaxosInsWriteRsp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpaxosInsWriteRsp(::google::protobuf::internal::ConstantInitialized);

  EpaxosInsWriteRsp(const EpaxosInsWriteRsp& from);
  EpaxosInsWriteRsp(EpaxosInsWriteRsp&& from) noexcept
    : EpaxosInsWriteRsp() {
    *this = ::std::move(from);
  }

  inline EpaxosInsWriteRsp& operator=(const EpaxosInsWriteRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpaxosInsWriteRsp& operator=(EpaxosInsWriteRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpaxosInsWriteRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpaxosInsWriteRsp* internal_default_instance() {
    return reinterpret_cast<const EpaxosInsWriteRsp*>(
               &_EpaxosInsWriteRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EpaxosInsWriteRsp& a, EpaxosInsWriteRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(EpaxosInsWriteRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpaxosInsWriteRsp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpaxosInsWriteRsp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpaxosInsWriteRsp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpaxosInsWriteRsp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpaxosInsWriteRsp& from) {
    EpaxosInsWriteRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpaxosInsWriteRsp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpaxosInsWriteRsp";
  }
  protected:
  explicit EpaxosInsWriteRsp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInsRspFieldNumber = 2,
    kResCodeFieldNumber = 1,
  };
  // .epxos_instance_proto.EpIns ins_rsp = 2;
  bool has_ins_rsp() const;
  void clear_ins_rsp() ;
  const ::epxos_instance_proto::EpIns& ins_rsp() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpIns* release_ins_rsp();
  ::epxos_instance_proto::EpIns* mutable_ins_rsp();
  void set_allocated_ins_rsp(::epxos_instance_proto::EpIns* value);
  void unsafe_arena_set_allocated_ins_rsp(::epxos_instance_proto::EpIns* value);
  ::epxos_instance_proto::EpIns* unsafe_arena_release_ins_rsp();

  private:
  const ::epxos_instance_proto::EpIns& _internal_ins_rsp() const;
  ::epxos_instance_proto::EpIns* _internal_mutable_ins_rsp();

  public:
  // int32 res_code = 1;
  void clear_res_code() ;
  ::int32_t res_code() const;
  void set_res_code(::int32_t value);

  private:
  ::int32_t _internal_res_code() const;
  void _internal_set_res_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpaxosInsWriteRsp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::epxos_instance_proto::EpIns* ins_rsp_;
    ::int32_t res_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class EpaxosInsReadReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpaxosInsReadReq) */ {
 public:
  inline EpaxosInsReadReq() : EpaxosInsReadReq(nullptr) {}
  ~EpaxosInsReadReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpaxosInsReadReq(::google::protobuf::internal::ConstantInitialized);

  EpaxosInsReadReq(const EpaxosInsReadReq& from);
  EpaxosInsReadReq(EpaxosInsReadReq&& from) noexcept
    : EpaxosInsReadReq() {
    *this = ::std::move(from);
  }

  inline EpaxosInsReadReq& operator=(const EpaxosInsReadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpaxosInsReadReq& operator=(EpaxosInsReadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpaxosInsReadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpaxosInsReadReq* internal_default_instance() {
    return reinterpret_cast<const EpaxosInsReadReq*>(
               &_EpaxosInsReadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EpaxosInsReadReq& a, EpaxosInsReadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EpaxosInsReadReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpaxosInsReadReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpaxosInsReadReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpaxosInsReadReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpaxosInsReadReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpaxosInsReadReq& from) {
    EpaxosInsReadReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpaxosInsReadReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpaxosInsReadReq";
  }
  protected:
  explicit EpaxosInsReadReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated string keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, std::size_t size);
  void set_keys(int index, absl::string_view value);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, std::size_t size);
  void add_keys(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_keys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_keys();

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpaxosInsReadReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      50, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> keys_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};// -------------------------------------------------------------------

class EpaxosInsReadRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:epxos_instance_proto.EpaxosInsReadRsp) */ {
 public:
  inline EpaxosInsReadRsp() : EpaxosInsReadRsp(nullptr) {}
  ~EpaxosInsReadRsp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EpaxosInsReadRsp(::google::protobuf::internal::ConstantInitialized);

  EpaxosInsReadRsp(const EpaxosInsReadRsp& from);
  EpaxosInsReadRsp(EpaxosInsReadRsp&& from) noexcept
    : EpaxosInsReadRsp() {
    *this = ::std::move(from);
  }

  inline EpaxosInsReadRsp& operator=(const EpaxosInsReadRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpaxosInsReadRsp& operator=(EpaxosInsReadRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpaxosInsReadRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpaxosInsReadRsp* internal_default_instance() {
    return reinterpret_cast<const EpaxosInsReadRsp*>(
               &_EpaxosInsReadRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EpaxosInsReadRsp& a, EpaxosInsReadRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(EpaxosInsReadRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpaxosInsReadRsp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpaxosInsReadRsp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpaxosInsReadRsp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpaxosInsReadRsp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EpaxosInsReadRsp& from) {
    EpaxosInsReadRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpaxosInsReadRsp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "epxos_instance_proto.EpaxosInsReadRsp";
  }
  protected:
  explicit EpaxosInsReadRsp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 3,
    kInsRspFieldNumber = 2,
    kResCodeFieldNumber = 1,
  };
  // repeated .epxos_instance_proto.EpKeyValueItem kvs = 3;
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;

  public:
  void clear_kvs() ;
  ::epxos_instance_proto::EpKeyValueItem* mutable_kvs(int index);
  ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >*
      mutable_kvs();
  private:
  const ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>& _internal_kvs() const;
  ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>* _internal_mutable_kvs();
  public:
  const ::epxos_instance_proto::EpKeyValueItem& kvs(int index) const;
  ::epxos_instance_proto::EpKeyValueItem* add_kvs();
  const ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >&
      kvs() const;
  // .epxos_instance_proto.EpIns ins_rsp = 2;
  bool has_ins_rsp() const;
  void clear_ins_rsp() ;
  const ::epxos_instance_proto::EpIns& ins_rsp() const;
  PROTOBUF_NODISCARD ::epxos_instance_proto::EpIns* release_ins_rsp();
  ::epxos_instance_proto::EpIns* mutable_ins_rsp();
  void set_allocated_ins_rsp(::epxos_instance_proto::EpIns* value);
  void unsafe_arena_set_allocated_ins_rsp(::epxos_instance_proto::EpIns* value);
  ::epxos_instance_proto::EpIns* unsafe_arena_release_ins_rsp();

  private:
  const ::epxos_instance_proto::EpIns& _internal_ins_rsp() const;
  ::epxos_instance_proto::EpIns* _internal_mutable_ins_rsp();

  public:
  // int32 res_code = 1;
  void clear_res_code() ;
  ::int32_t res_code() const;
  void set_res_code(::int32_t value);

  private:
  ::int32_t _internal_res_code() const;
  void _internal_set_res_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:epxos_instance_proto.EpaxosInsReadRsp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem > kvs_;
    ::epxos_instance_proto::EpIns* ins_rsp_;
    ::int32_t res_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_instance_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EpIns

// uint64 insid = 2;
inline void EpIns::clear_insid() {
  _impl_.insid_ = ::uint64_t{0u};
}
inline ::uint64_t EpIns::insid() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpIns.insid)
  return _internal_insid();
}
inline void EpIns::set_insid(::uint64_t value) {
  _internal_set_insid(value);
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpIns.insid)
}
inline ::uint64_t EpIns::_internal_insid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.insid_;
}
inline void EpIns::_internal_set_insid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.insid_ = value;
}

// .epxos_instance_proto.EpNodeId nodeid = 3;
inline bool EpIns::has_nodeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nodeid_ != nullptr);
  return value;
}
inline const ::epxos_instance_proto::EpNodeId& EpIns::_internal_nodeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpNodeId* p = _impl_.nodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpNodeId&>(::epxos_instance_proto::_EpNodeId_default_instance_);
}
inline const ::epxos_instance_proto::EpNodeId& EpIns::nodeid() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpIns.nodeid)
  return _internal_nodeid();
}
inline void EpIns::unsafe_arena_set_allocated_nodeid(::epxos_instance_proto::EpNodeId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nodeid_);
  }
  _impl_.nodeid_ = reinterpret_cast<::epxos_instance_proto::EpNodeId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.EpIns.nodeid)
}
inline ::epxos_instance_proto::EpNodeId* EpIns::release_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpNodeId* released = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpNodeId* EpIns::unsafe_arena_release_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpIns.nodeid)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpNodeId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpNodeId* EpIns::_internal_mutable_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.nodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpNodeId>(GetArenaForAllocation());
    _impl_.nodeid_ = reinterpret_cast<::epxos_instance_proto::EpNodeId*>(p);
  }
  return _impl_.nodeid_;
}
inline ::epxos_instance_proto::EpNodeId* EpIns::mutable_nodeid() {
  ::epxos_instance_proto::EpNodeId* _msg = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpIns.nodeid)
  return _msg;
}
inline void EpIns::set_allocated_nodeid(::epxos_instance_proto::EpNodeId* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nodeid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.nodeid_ = reinterpret_cast<::epxos_instance_proto::EpNodeId*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpIns.nodeid)
}

// -------------------------------------------------------------------

// EpInstID

// uint64 seqid = 1;
inline void EpInstID::clear_seqid() {
  _impl_.seqid_ = ::uint64_t{0u};
}
inline ::uint64_t EpInstID::seqid() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpInstID.seqid)
  return _internal_seqid();
}
inline void EpInstID::set_seqid(::uint64_t value) {
  _internal_set_seqid(value);
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpInstID.seqid)
}
inline ::uint64_t EpInstID::_internal_seqid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seqid_;
}
inline void EpInstID::_internal_set_seqid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seqid_ = value;
}

// .epxos_instance_proto.EpIns iID = 2;
inline bool EpInstID::has_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.iid_ != nullptr);
  return value;
}
inline void EpInstID::clear_iid() {
  if (_impl_.iid_ != nullptr) _impl_.iid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::epxos_instance_proto::EpIns& EpInstID::_internal_iid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpIns* p = _impl_.iid_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpIns&>(::epxos_instance_proto::_EpIns_default_instance_);
}
inline const ::epxos_instance_proto::EpIns& EpInstID::iid() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpInstID.iID)
  return _internal_iid();
}
inline void EpInstID::unsafe_arena_set_allocated_iid(::epxos_instance_proto::EpIns* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.iid_);
  }
  _impl_.iid_ = reinterpret_cast<::epxos_instance_proto::EpIns*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.EpInstID.iID)
}
inline ::epxos_instance_proto::EpIns* EpInstID::release_iid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpIns* released = _impl_.iid_;
  _impl_.iid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpIns* EpInstID::unsafe_arena_release_iid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpInstID.iID)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpIns* temp = _impl_.iid_;
  _impl_.iid_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpIns* EpInstID::_internal_mutable_iid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.iid_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpIns>(GetArenaForAllocation());
    _impl_.iid_ = reinterpret_cast<::epxos_instance_proto::EpIns*>(p);
  }
  return _impl_.iid_;
}
inline ::epxos_instance_proto::EpIns* EpInstID::mutable_iid() {
  ::epxos_instance_proto::EpIns* _msg = _internal_mutable_iid();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpInstID.iID)
  return _msg;
}
inline void EpInstID::set_allocated_iid(::epxos_instance_proto::EpIns* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::epxos_instance_proto::EpIns*>(_impl_.iid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::epxos_instance_proto::EpIns*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.iid_ = reinterpret_cast<::epxos_instance_proto::EpIns*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpInstID.iID)
}

// -------------------------------------------------------------------

// EpDepsIds

// repeated .epxos_instance_proto.EpInstID arrdps = 1;
inline int EpDepsIds::_internal_arrdps_size() const {
  return _internal_arrdps().size();
}
inline int EpDepsIds::arrdps_size() const {
  return _internal_arrdps_size();
}
inline void EpDepsIds::clear_arrdps() {
  _internal_mutable_arrdps()->Clear();
}
inline ::epxos_instance_proto::EpInstID* EpDepsIds::mutable_arrdps(int index) {
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpDepsIds.arrdps)
  return _internal_mutable_arrdps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpInstID >*
EpDepsIds::mutable_arrdps() {
  // @@protoc_insertion_point(field_mutable_list:epxos_instance_proto.EpDepsIds.arrdps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_arrdps();
}
inline const ::epxos_instance_proto::EpInstID& EpDepsIds::arrdps(int index) const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpDepsIds.arrdps)
    return _internal_arrdps().Get(index);
}
inline ::epxos_instance_proto::EpInstID* EpDepsIds::add_arrdps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::epxos_instance_proto::EpInstID* _add = _internal_mutable_arrdps()->Add();
  // @@protoc_insertion_point(field_add:epxos_instance_proto.EpDepsIds.arrdps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpInstID >&
EpDepsIds::arrdps() const {
  // @@protoc_insertion_point(field_list:epxos_instance_proto.EpDepsIds.arrdps)
  return _internal_arrdps();
}
inline const ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpInstID>&
EpDepsIds::_internal_arrdps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arrdps_;
}
inline ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpInstID>*
EpDepsIds::_internal_mutable_arrdps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.arrdps_;
}

// uint32 version = 2;
inline void EpDepsIds::clear_version() {
  _impl_.version_ = 0u;
}
inline ::uint32_t EpDepsIds::version() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpDepsIds.version)
  return _internal_version();
}
inline void EpDepsIds::set_version(::uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpDepsIds.version)
}
inline ::uint32_t EpDepsIds::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_;
}
inline void EpDepsIds::_internal_set_version(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_ = value;
}

// -------------------------------------------------------------------

// EpKeyValueItem

// string key = 1;
inline void EpKeyValueItem::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& EpKeyValueItem::key() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpKeyValueItem.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EpKeyValueItem::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpKeyValueItem.key)
}
inline std::string* EpKeyValueItem::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpKeyValueItem.key)
  return _s;
}
inline const std::string& EpKeyValueItem::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void EpKeyValueItem::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* EpKeyValueItem::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* EpKeyValueItem::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpKeyValueItem.key)
  return _impl_.key_.Release();
}
inline void EpKeyValueItem::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpKeyValueItem.key)
}

// optional string value = 2;
inline bool EpKeyValueItem::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EpKeyValueItem::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EpKeyValueItem::value() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpKeyValueItem.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EpKeyValueItem::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpKeyValueItem.value)
}
inline std::string* EpKeyValueItem::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpKeyValueItem.value)
  return _s;
}
inline const std::string& EpKeyValueItem::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void EpKeyValueItem::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* EpKeyValueItem::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* EpKeyValueItem::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpKeyValueItem.value)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void EpKeyValueItem::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpKeyValueItem.value)
}

// -------------------------------------------------------------------

// EpInstance

// .epxos_instance_proto.EpInstID iID = 1;
inline bool EpInstance::has_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.iid_ != nullptr);
  return value;
}
inline void EpInstance::clear_iid() {
  if (_impl_.iid_ != nullptr) _impl_.iid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::epxos_instance_proto::EpInstID& EpInstance::_internal_iid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpInstID* p = _impl_.iid_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpInstID&>(::epxos_instance_proto::_EpInstID_default_instance_);
}
inline const ::epxos_instance_proto::EpInstID& EpInstance::iid() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpInstance.iID)
  return _internal_iid();
}
inline void EpInstance::unsafe_arena_set_allocated_iid(::epxos_instance_proto::EpInstID* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.iid_);
  }
  _impl_.iid_ = reinterpret_cast<::epxos_instance_proto::EpInstID*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.EpInstance.iID)
}
inline ::epxos_instance_proto::EpInstID* EpInstance::release_iid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpInstID* released = _impl_.iid_;
  _impl_.iid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpInstID* EpInstance::unsafe_arena_release_iid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpInstance.iID)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpInstID* temp = _impl_.iid_;
  _impl_.iid_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpInstID* EpInstance::_internal_mutable_iid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.iid_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpInstID>(GetArenaForAllocation());
    _impl_.iid_ = reinterpret_cast<::epxos_instance_proto::EpInstID*>(p);
  }
  return _impl_.iid_;
}
inline ::epxos_instance_proto::EpInstID* EpInstance::mutable_iid() {
  ::epxos_instance_proto::EpInstID* _msg = _internal_mutable_iid();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpInstance.iID)
  return _msg;
}
inline void EpInstance::set_allocated_iid(::epxos_instance_proto::EpInstID* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::epxos_instance_proto::EpInstID*>(_impl_.iid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::epxos_instance_proto::EpInstID*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.iid_ = reinterpret_cast<::epxos_instance_proto::EpInstID*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpInstance.iID)
}

// .epxos_instance_proto.EpWorkState sate = 2;
inline void EpInstance::clear_sate() {
  _impl_.sate_ = 0;
}
inline ::epxos_instance_proto::EpWorkState EpInstance::sate() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpInstance.sate)
  return _internal_sate();
}
inline void EpInstance::set_sate(::epxos_instance_proto::EpWorkState value) {
  _internal_set_sate(value);
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpInstance.sate)
}
inline ::epxos_instance_proto::EpWorkState EpInstance::_internal_sate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::epxos_instance_proto::EpWorkState>(_impl_.sate_);
}
inline void EpInstance::_internal_set_sate(::epxos_instance_proto::EpWorkState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sate_ = value;
}

// uint32 ballot_num = 3;
inline void EpInstance::clear_ballot_num() {
  _impl_.ballot_num_ = 0u;
}
inline ::uint32_t EpInstance::ballot_num() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpInstance.ballot_num)
  return _internal_ballot_num();
}
inline void EpInstance::set_ballot_num(::uint32_t value) {
  _internal_set_ballot_num(value);
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpInstance.ballot_num)
}
inline ::uint32_t EpInstance::_internal_ballot_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ballot_num_;
}
inline void EpInstance::_internal_set_ballot_num(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ballot_num_ = value;
}

// optional .epxos_instance_proto.EpDepsIds arryids = 4;
inline bool EpInstance::has_arryids() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arryids_ != nullptr);
  return value;
}
inline void EpInstance::clear_arryids() {
  if (_impl_.arryids_ != nullptr) _impl_.arryids_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::epxos_instance_proto::EpDepsIds& EpInstance::_internal_arryids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpDepsIds* p = _impl_.arryids_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpDepsIds&>(::epxos_instance_proto::_EpDepsIds_default_instance_);
}
inline const ::epxos_instance_proto::EpDepsIds& EpInstance::arryids() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpInstance.arryids)
  return _internal_arryids();
}
inline void EpInstance::unsafe_arena_set_allocated_arryids(::epxos_instance_proto::EpDepsIds* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arryids_);
  }
  _impl_.arryids_ = reinterpret_cast<::epxos_instance_proto::EpDepsIds*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.EpInstance.arryids)
}
inline ::epxos_instance_proto::EpDepsIds* EpInstance::release_arryids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::epxos_instance_proto::EpDepsIds* released = _impl_.arryids_;
  _impl_.arryids_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpDepsIds* EpInstance::unsafe_arena_release_arryids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpInstance.arryids)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::epxos_instance_proto::EpDepsIds* temp = _impl_.arryids_;
  _impl_.arryids_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpDepsIds* EpInstance::_internal_mutable_arryids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.arryids_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpDepsIds>(GetArenaForAllocation());
    _impl_.arryids_ = reinterpret_cast<::epxos_instance_proto::EpDepsIds*>(p);
  }
  return _impl_.arryids_;
}
inline ::epxos_instance_proto::EpDepsIds* EpInstance::mutable_arryids() {
  ::epxos_instance_proto::EpDepsIds* _msg = _internal_mutable_arryids();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpInstance.arryids)
  return _msg;
}
inline void EpInstance::set_allocated_arryids(::epxos_instance_proto::EpDepsIds* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::epxos_instance_proto::EpDepsIds*>(_impl_.arryids_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::epxos_instance_proto::EpDepsIds*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.arryids_ = reinterpret_cast<::epxos_instance_proto::EpDepsIds*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpInstance.arryids)
}

// uint32 ack_num = 5;
inline void EpInstance::clear_ack_num() {
  _impl_.ack_num_ = 0u;
}
inline ::uint32_t EpInstance::ack_num() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpInstance.ack_num)
  return _internal_ack_num();
}
inline void EpInstance::set_ack_num(::uint32_t value) {
  _internal_set_ack_num(value);
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpInstance.ack_num)
}
inline ::uint32_t EpInstance::_internal_ack_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ack_num_;
}
inline void EpInstance::_internal_set_ack_num(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ack_num_ = value;
}

// repeated .epxos_instance_proto.EpKeyValueItem kvs = 6;
inline int EpInstance::_internal_kvs_size() const {
  return _internal_kvs().size();
}
inline int EpInstance::kvs_size() const {
  return _internal_kvs_size();
}
inline void EpInstance::clear_kvs() {
  _internal_mutable_kvs()->Clear();
}
inline ::epxos_instance_proto::EpKeyValueItem* EpInstance::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpInstance.kvs)
  return _internal_mutable_kvs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >*
EpInstance::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:epxos_instance_proto.EpInstance.kvs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_kvs();
}
inline const ::epxos_instance_proto::EpKeyValueItem& EpInstance::kvs(int index) const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpInstance.kvs)
    return _internal_kvs().Get(index);
}
inline ::epxos_instance_proto::EpKeyValueItem* EpInstance::add_kvs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::epxos_instance_proto::EpKeyValueItem* _add = _internal_mutable_kvs()->Add();
  // @@protoc_insertion_point(field_add:epxos_instance_proto.EpInstance.kvs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >&
EpInstance::kvs() const {
  // @@protoc_insertion_point(field_list:epxos_instance_proto.EpInstance.kvs)
  return _internal_kvs();
}
inline const ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>&
EpInstance::_internal_kvs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kvs_;
}
inline ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>*
EpInstance::_internal_mutable_kvs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.kvs_;
}

// -------------------------------------------------------------------

// EpValueItem

// optional string value = 1;
inline bool EpValueItem::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EpValueItem::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EpValueItem::value() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpValueItem.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EpValueItem::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpValueItem.value)
}
inline std::string* EpValueItem::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpValueItem.value)
  return _s;
}
inline const std::string& EpValueItem::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void EpValueItem::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* EpValueItem::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* EpValueItem::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpValueItem.value)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void EpValueItem::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpValueItem.value)
}

// .epxos_instance_proto.EpInstID iID = 2;
inline bool EpValueItem::has_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.iid_ != nullptr);
  return value;
}
inline void EpValueItem::clear_iid() {
  if (_impl_.iid_ != nullptr) _impl_.iid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::epxos_instance_proto::EpInstID& EpValueItem::_internal_iid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpInstID* p = _impl_.iid_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpInstID&>(::epxos_instance_proto::_EpInstID_default_instance_);
}
inline const ::epxos_instance_proto::EpInstID& EpValueItem::iid() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpValueItem.iID)
  return _internal_iid();
}
inline void EpValueItem::unsafe_arena_set_allocated_iid(::epxos_instance_proto::EpInstID* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.iid_);
  }
  _impl_.iid_ = reinterpret_cast<::epxos_instance_proto::EpInstID*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.EpValueItem.iID)
}
inline ::epxos_instance_proto::EpInstID* EpValueItem::release_iid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::epxos_instance_proto::EpInstID* released = _impl_.iid_;
  _impl_.iid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpInstID* EpValueItem::unsafe_arena_release_iid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpValueItem.iID)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::epxos_instance_proto::EpInstID* temp = _impl_.iid_;
  _impl_.iid_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpInstID* EpValueItem::_internal_mutable_iid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.iid_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpInstID>(GetArenaForAllocation());
    _impl_.iid_ = reinterpret_cast<::epxos_instance_proto::EpInstID*>(p);
  }
  return _impl_.iid_;
}
inline ::epxos_instance_proto::EpInstID* EpValueItem::mutable_iid() {
  ::epxos_instance_proto::EpInstID* _msg = _internal_mutable_iid();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpValueItem.iID)
  return _msg;
}
inline void EpValueItem::set_allocated_iid(::epxos_instance_proto::EpInstID* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::epxos_instance_proto::EpInstID*>(_impl_.iid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::epxos_instance_proto::EpInstID*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.iid_ = reinterpret_cast<::epxos_instance_proto::EpInstID*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpValueItem.iID)
}

// -------------------------------------------------------------------

// EpValueStorageBody

// optional .epxos_instance_proto.EpValueItem items = 1;
inline bool EpValueStorageBody::has_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.items_ != nullptr);
  return value;
}
inline void EpValueStorageBody::clear_items() {
  if (_impl_.items_ != nullptr) _impl_.items_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::epxos_instance_proto::EpValueItem& EpValueStorageBody::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpValueItem* p = _impl_.items_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpValueItem&>(::epxos_instance_proto::_EpValueItem_default_instance_);
}
inline const ::epxos_instance_proto::EpValueItem& EpValueStorageBody::items() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpValueStorageBody.items)
  return _internal_items();
}
inline void EpValueStorageBody::unsafe_arena_set_allocated_items(::epxos_instance_proto::EpValueItem* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.items_);
  }
  _impl_.items_ = reinterpret_cast<::epxos_instance_proto::EpValueItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.EpValueStorageBody.items)
}
inline ::epxos_instance_proto::EpValueItem* EpValueStorageBody::release_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpValueItem* released = _impl_.items_;
  _impl_.items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpValueItem* EpValueStorageBody::unsafe_arena_release_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpValueStorageBody.items)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpValueItem* temp = _impl_.items_;
  _impl_.items_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpValueItem* EpValueStorageBody::_internal_mutable_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.items_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpValueItem>(GetArenaForAllocation());
    _impl_.items_ = reinterpret_cast<::epxos_instance_proto::EpValueItem*>(p);
  }
  return _impl_.items_;
}
inline ::epxos_instance_proto::EpValueItem* EpValueStorageBody::mutable_items() {
  ::epxos_instance_proto::EpValueItem* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpValueStorageBody.items)
  return _msg;
}
inline void EpValueStorageBody::set_allocated_items(::epxos_instance_proto::EpValueItem* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::epxos_instance_proto::EpValueItem*>(_impl_.items_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::epxos_instance_proto::EpValueItem*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.items_ = reinterpret_cast<::epxos_instance_proto::EpValueItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpValueStorageBody.items)
}

// -------------------------------------------------------------------

// InstanceSwapMsg

// .epxos_instance_proto.EpInstance insc = 1;
inline bool InstanceSwapMsg::has_insc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.insc_ != nullptr);
  return value;
}
inline void InstanceSwapMsg::clear_insc() {
  if (_impl_.insc_ != nullptr) _impl_.insc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::epxos_instance_proto::EpInstance& InstanceSwapMsg::_internal_insc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpInstance* p = _impl_.insc_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpInstance&>(::epxos_instance_proto::_EpInstance_default_instance_);
}
inline const ::epxos_instance_proto::EpInstance& InstanceSwapMsg::insc() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.InstanceSwapMsg.insc)
  return _internal_insc();
}
inline void InstanceSwapMsg::unsafe_arena_set_allocated_insc(::epxos_instance_proto::EpInstance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.insc_);
  }
  _impl_.insc_ = reinterpret_cast<::epxos_instance_proto::EpInstance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.InstanceSwapMsg.insc)
}
inline ::epxos_instance_proto::EpInstance* InstanceSwapMsg::release_insc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpInstance* released = _impl_.insc_;
  _impl_.insc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpInstance* InstanceSwapMsg::unsafe_arena_release_insc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.InstanceSwapMsg.insc)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpInstance* temp = _impl_.insc_;
  _impl_.insc_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpInstance* InstanceSwapMsg::_internal_mutable_insc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.insc_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpInstance>(GetArenaForAllocation());
    _impl_.insc_ = reinterpret_cast<::epxos_instance_proto::EpInstance*>(p);
  }
  return _impl_.insc_;
}
inline ::epxos_instance_proto::EpInstance* InstanceSwapMsg::mutable_insc() {
  ::epxos_instance_proto::EpInstance* _msg = _internal_mutable_insc();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.InstanceSwapMsg.insc)
  return _msg;
}
inline void InstanceSwapMsg::set_allocated_insc(::epxos_instance_proto::EpInstance* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::epxos_instance_proto::EpInstance*>(_impl_.insc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::epxos_instance_proto::EpInstance*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.insc_ = reinterpret_cast<::epxos_instance_proto::EpInstance*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.InstanceSwapMsg.insc)
}

// .epxos_instance_proto.EpNodeId to_node = 2;
inline bool InstanceSwapMsg::has_to_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.to_node_ != nullptr);
  return value;
}
inline const ::epxos_instance_proto::EpNodeId& InstanceSwapMsg::_internal_to_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpNodeId* p = _impl_.to_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpNodeId&>(::epxos_instance_proto::_EpNodeId_default_instance_);
}
inline const ::epxos_instance_proto::EpNodeId& InstanceSwapMsg::to_node() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.InstanceSwapMsg.to_node)
  return _internal_to_node();
}
inline void InstanceSwapMsg::unsafe_arena_set_allocated_to_node(::epxos_instance_proto::EpNodeId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.to_node_);
  }
  _impl_.to_node_ = reinterpret_cast<::epxos_instance_proto::EpNodeId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.InstanceSwapMsg.to_node)
}
inline ::epxos_instance_proto::EpNodeId* InstanceSwapMsg::release_to_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::epxos_instance_proto::EpNodeId* released = _impl_.to_node_;
  _impl_.to_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpNodeId* InstanceSwapMsg::unsafe_arena_release_to_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.InstanceSwapMsg.to_node)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::epxos_instance_proto::EpNodeId* temp = _impl_.to_node_;
  _impl_.to_node_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpNodeId* InstanceSwapMsg::_internal_mutable_to_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.to_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpNodeId>(GetArenaForAllocation());
    _impl_.to_node_ = reinterpret_cast<::epxos_instance_proto::EpNodeId*>(p);
  }
  return _impl_.to_node_;
}
inline ::epxos_instance_proto::EpNodeId* InstanceSwapMsg::mutable_to_node() {
  ::epxos_instance_proto::EpNodeId* _msg = _internal_mutable_to_node();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.InstanceSwapMsg.to_node)
  return _msg;
}
inline void InstanceSwapMsg::set_allocated_to_node(::epxos_instance_proto::EpNodeId* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.to_node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.to_node_ = reinterpret_cast<::epxos_instance_proto::EpNodeId*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.InstanceSwapMsg.to_node)
}

// .epxos_instance_proto.EpNodeId from_node = 3;
inline bool InstanceSwapMsg::has_from_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_node_ != nullptr);
  return value;
}
inline const ::epxos_instance_proto::EpNodeId& InstanceSwapMsg::_internal_from_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpNodeId* p = _impl_.from_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpNodeId&>(::epxos_instance_proto::_EpNodeId_default_instance_);
}
inline const ::epxos_instance_proto::EpNodeId& InstanceSwapMsg::from_node() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.InstanceSwapMsg.from_node)
  return _internal_from_node();
}
inline void InstanceSwapMsg::unsafe_arena_set_allocated_from_node(::epxos_instance_proto::EpNodeId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_node_);
  }
  _impl_.from_node_ = reinterpret_cast<::epxos_instance_proto::EpNodeId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.InstanceSwapMsg.from_node)
}
inline ::epxos_instance_proto::EpNodeId* InstanceSwapMsg::release_from_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::epxos_instance_proto::EpNodeId* released = _impl_.from_node_;
  _impl_.from_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpNodeId* InstanceSwapMsg::unsafe_arena_release_from_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.InstanceSwapMsg.from_node)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::epxos_instance_proto::EpNodeId* temp = _impl_.from_node_;
  _impl_.from_node_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpNodeId* InstanceSwapMsg::_internal_mutable_from_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.from_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpNodeId>(GetArenaForAllocation());
    _impl_.from_node_ = reinterpret_cast<::epxos_instance_proto::EpNodeId*>(p);
  }
  return _impl_.from_node_;
}
inline ::epxos_instance_proto::EpNodeId* InstanceSwapMsg::mutable_from_node() {
  ::epxos_instance_proto::EpNodeId* _msg = _internal_mutable_from_node();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.InstanceSwapMsg.from_node)
  return _msg;
}
inline void InstanceSwapMsg::set_allocated_from_node(::epxos_instance_proto::EpNodeId* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.from_node_ = reinterpret_cast<::epxos_instance_proto::EpNodeId*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.InstanceSwapMsg.from_node)
}

// -------------------------------------------------------------------

// EpaxosInsWriteReq

// repeated .epxos_instance_proto.EpKeyValueItem list = 1;
inline int EpaxosInsWriteReq::_internal_list_size() const {
  return _internal_list().size();
}
inline int EpaxosInsWriteReq::list_size() const {
  return _internal_list_size();
}
inline void EpaxosInsWriteReq::clear_list() {
  _internal_mutable_list()->Clear();
}
inline ::epxos_instance_proto::EpKeyValueItem* EpaxosInsWriteReq::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpaxosInsWriteReq.list)
  return _internal_mutable_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >*
EpaxosInsWriteReq::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:epxos_instance_proto.EpaxosInsWriteReq.list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_list();
}
inline const ::epxos_instance_proto::EpKeyValueItem& EpaxosInsWriteReq::list(int index) const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpaxosInsWriteReq.list)
    return _internal_list().Get(index);
}
inline ::epxos_instance_proto::EpKeyValueItem* EpaxosInsWriteReq::add_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::epxos_instance_proto::EpKeyValueItem* _add = _internal_mutable_list()->Add();
  // @@protoc_insertion_point(field_add:epxos_instance_proto.EpaxosInsWriteReq.list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >&
EpaxosInsWriteReq::list() const {
  // @@protoc_insertion_point(field_list:epxos_instance_proto.EpaxosInsWriteReq.list)
  return _internal_list();
}
inline const ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>&
EpaxosInsWriteReq::_internal_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.list_;
}
inline ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>*
EpaxosInsWriteReq::_internal_mutable_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.list_;
}

// -------------------------------------------------------------------

// EpaxosInsWriteRsp

// int32 res_code = 1;
inline void EpaxosInsWriteRsp::clear_res_code() {
  _impl_.res_code_ = 0;
}
inline ::int32_t EpaxosInsWriteRsp::res_code() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpaxosInsWriteRsp.res_code)
  return _internal_res_code();
}
inline void EpaxosInsWriteRsp::set_res_code(::int32_t value) {
  _internal_set_res_code(value);
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpaxosInsWriteRsp.res_code)
}
inline ::int32_t EpaxosInsWriteRsp::_internal_res_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.res_code_;
}
inline void EpaxosInsWriteRsp::_internal_set_res_code(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.res_code_ = value;
}

// .epxos_instance_proto.EpIns ins_rsp = 2;
inline bool EpaxosInsWriteRsp::has_ins_rsp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ins_rsp_ != nullptr);
  return value;
}
inline void EpaxosInsWriteRsp::clear_ins_rsp() {
  if (_impl_.ins_rsp_ != nullptr) _impl_.ins_rsp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::epxos_instance_proto::EpIns& EpaxosInsWriteRsp::_internal_ins_rsp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpIns* p = _impl_.ins_rsp_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpIns&>(::epxos_instance_proto::_EpIns_default_instance_);
}
inline const ::epxos_instance_proto::EpIns& EpaxosInsWriteRsp::ins_rsp() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpaxosInsWriteRsp.ins_rsp)
  return _internal_ins_rsp();
}
inline void EpaxosInsWriteRsp::unsafe_arena_set_allocated_ins_rsp(::epxos_instance_proto::EpIns* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ins_rsp_);
  }
  _impl_.ins_rsp_ = reinterpret_cast<::epxos_instance_proto::EpIns*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.EpaxosInsWriteRsp.ins_rsp)
}
inline ::epxos_instance_proto::EpIns* EpaxosInsWriteRsp::release_ins_rsp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpIns* released = _impl_.ins_rsp_;
  _impl_.ins_rsp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpIns* EpaxosInsWriteRsp::unsafe_arena_release_ins_rsp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpaxosInsWriteRsp.ins_rsp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpIns* temp = _impl_.ins_rsp_;
  _impl_.ins_rsp_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpIns* EpaxosInsWriteRsp::_internal_mutable_ins_rsp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ins_rsp_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpIns>(GetArenaForAllocation());
    _impl_.ins_rsp_ = reinterpret_cast<::epxos_instance_proto::EpIns*>(p);
  }
  return _impl_.ins_rsp_;
}
inline ::epxos_instance_proto::EpIns* EpaxosInsWriteRsp::mutable_ins_rsp() {
  ::epxos_instance_proto::EpIns* _msg = _internal_mutable_ins_rsp();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpaxosInsWriteRsp.ins_rsp)
  return _msg;
}
inline void EpaxosInsWriteRsp::set_allocated_ins_rsp(::epxos_instance_proto::EpIns* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::epxos_instance_proto::EpIns*>(_impl_.ins_rsp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::epxos_instance_proto::EpIns*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ins_rsp_ = reinterpret_cast<::epxos_instance_proto::EpIns*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpaxosInsWriteRsp.ins_rsp)
}

// -------------------------------------------------------------------

// EpaxosInsReadReq

// repeated string keys = 1;
inline int EpaxosInsReadReq::_internal_keys_size() const {
  return _internal_keys().size();
}
inline int EpaxosInsReadReq::keys_size() const {
  return _internal_keys_size();
}
inline void EpaxosInsReadReq::clear_keys() {
  _internal_mutable_keys()->Clear();
}
inline std::string* EpaxosInsReadReq::add_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_keys()->Add();
  // @@protoc_insertion_point(field_add_mutable:epxos_instance_proto.EpaxosInsReadReq.keys)
  return _s;
}
inline const std::string& EpaxosInsReadReq::keys(int index) const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpaxosInsReadReq.keys)
  return _internal_keys().Get(index);
}
inline std::string* EpaxosInsReadReq::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpaxosInsReadReq.keys)
  return _internal_mutable_keys()->Mutable(index);
}
inline void EpaxosInsReadReq::set_keys(int index, const std::string& value) {
  _internal_mutable_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpaxosInsReadReq.keys)
}
inline void EpaxosInsReadReq::set_keys(int index, std::string&& value) {
  _internal_mutable_keys()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpaxosInsReadReq.keys)
}
inline void EpaxosInsReadReq::set_keys(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:epxos_instance_proto.EpaxosInsReadReq.keys)
}
inline void EpaxosInsReadReq::set_keys(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_keys()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:epxos_instance_proto.EpaxosInsReadReq.keys)
}
inline void EpaxosInsReadReq::set_keys(int index, absl::string_view value) {
  _internal_mutable_keys()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:epxos_instance_proto.EpaxosInsReadReq.keys)
}
inline void EpaxosInsReadReq::add_keys(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:epxos_instance_proto.EpaxosInsReadReq.keys)
}
inline void EpaxosInsReadReq::add_keys(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_keys()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:epxos_instance_proto.EpaxosInsReadReq.keys)
}
inline void EpaxosInsReadReq::add_keys(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:epxos_instance_proto.EpaxosInsReadReq.keys)
}
inline void EpaxosInsReadReq::add_keys(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_keys()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:epxos_instance_proto.EpaxosInsReadReq.keys)
}
inline void EpaxosInsReadReq::add_keys(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_keys()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:epxos_instance_proto.EpaxosInsReadReq.keys)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
EpaxosInsReadReq::keys() const {
  // @@protoc_insertion_point(field_list:epxos_instance_proto.EpaxosInsReadReq.keys)
  return _internal_keys();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* EpaxosInsReadReq::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:epxos_instance_proto.EpaxosInsReadReq.keys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_keys();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
EpaxosInsReadReq::_internal_keys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keys_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
EpaxosInsReadReq::_internal_mutable_keys() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// EpaxosInsReadRsp

// int32 res_code = 1;
inline void EpaxosInsReadRsp::clear_res_code() {
  _impl_.res_code_ = 0;
}
inline ::int32_t EpaxosInsReadRsp::res_code() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpaxosInsReadRsp.res_code)
  return _internal_res_code();
}
inline void EpaxosInsReadRsp::set_res_code(::int32_t value) {
  _internal_set_res_code(value);
  // @@protoc_insertion_point(field_set:epxos_instance_proto.EpaxosInsReadRsp.res_code)
}
inline ::int32_t EpaxosInsReadRsp::_internal_res_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.res_code_;
}
inline void EpaxosInsReadRsp::_internal_set_res_code(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.res_code_ = value;
}

// .epxos_instance_proto.EpIns ins_rsp = 2;
inline bool EpaxosInsReadRsp::has_ins_rsp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ins_rsp_ != nullptr);
  return value;
}
inline void EpaxosInsReadRsp::clear_ins_rsp() {
  if (_impl_.ins_rsp_ != nullptr) _impl_.ins_rsp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::epxos_instance_proto::EpIns& EpaxosInsReadRsp::_internal_ins_rsp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::epxos_instance_proto::EpIns* p = _impl_.ins_rsp_;
  return p != nullptr ? *p : reinterpret_cast<const ::epxos_instance_proto::EpIns&>(::epxos_instance_proto::_EpIns_default_instance_);
}
inline const ::epxos_instance_proto::EpIns& EpaxosInsReadRsp::ins_rsp() const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpaxosInsReadRsp.ins_rsp)
  return _internal_ins_rsp();
}
inline void EpaxosInsReadRsp::unsafe_arena_set_allocated_ins_rsp(::epxos_instance_proto::EpIns* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ins_rsp_);
  }
  _impl_.ins_rsp_ = reinterpret_cast<::epxos_instance_proto::EpIns*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epxos_instance_proto.EpaxosInsReadRsp.ins_rsp)
}
inline ::epxos_instance_proto::EpIns* EpaxosInsReadRsp::release_ins_rsp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpIns* released = _impl_.ins_rsp_;
  _impl_.ins_rsp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::epxos_instance_proto::EpIns* EpaxosInsReadRsp::unsafe_arena_release_ins_rsp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:epxos_instance_proto.EpaxosInsReadRsp.ins_rsp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epxos_instance_proto::EpIns* temp = _impl_.ins_rsp_;
  _impl_.ins_rsp_ = nullptr;
  return temp;
}
inline ::epxos_instance_proto::EpIns* EpaxosInsReadRsp::_internal_mutable_ins_rsp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ins_rsp_ == nullptr) {
    auto* p = CreateMaybeMessage<::epxos_instance_proto::EpIns>(GetArenaForAllocation());
    _impl_.ins_rsp_ = reinterpret_cast<::epxos_instance_proto::EpIns*>(p);
  }
  return _impl_.ins_rsp_;
}
inline ::epxos_instance_proto::EpIns* EpaxosInsReadRsp::mutable_ins_rsp() {
  ::epxos_instance_proto::EpIns* _msg = _internal_mutable_ins_rsp();
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpaxosInsReadRsp.ins_rsp)
  return _msg;
}
inline void EpaxosInsReadRsp::set_allocated_ins_rsp(::epxos_instance_proto::EpIns* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::epxos_instance_proto::EpIns*>(_impl_.ins_rsp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::epxos_instance_proto::EpIns*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ins_rsp_ = reinterpret_cast<::epxos_instance_proto::EpIns*>(value);
  // @@protoc_insertion_point(field_set_allocated:epxos_instance_proto.EpaxosInsReadRsp.ins_rsp)
}

// repeated .epxos_instance_proto.EpKeyValueItem kvs = 3;
inline int EpaxosInsReadRsp::_internal_kvs_size() const {
  return _internal_kvs().size();
}
inline int EpaxosInsReadRsp::kvs_size() const {
  return _internal_kvs_size();
}
inline void EpaxosInsReadRsp::clear_kvs() {
  _internal_mutable_kvs()->Clear();
}
inline ::epxos_instance_proto::EpKeyValueItem* EpaxosInsReadRsp::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:epxos_instance_proto.EpaxosInsReadRsp.kvs)
  return _internal_mutable_kvs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >*
EpaxosInsReadRsp::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:epxos_instance_proto.EpaxosInsReadRsp.kvs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_kvs();
}
inline const ::epxos_instance_proto::EpKeyValueItem& EpaxosInsReadRsp::kvs(int index) const {
  // @@protoc_insertion_point(field_get:epxos_instance_proto.EpaxosInsReadRsp.kvs)
    return _internal_kvs().Get(index);
}
inline ::epxos_instance_proto::EpKeyValueItem* EpaxosInsReadRsp::add_kvs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::epxos_instance_proto::EpKeyValueItem* _add = _internal_mutable_kvs()->Add();
  // @@protoc_insertion_point(field_add:epxos_instance_proto.EpaxosInsReadRsp.kvs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::epxos_instance_proto::EpKeyValueItem >&
EpaxosInsReadRsp::kvs() const {
  // @@protoc_insertion_point(field_list:epxos_instance_proto.EpaxosInsReadRsp.kvs)
  return _internal_kvs();
}
inline const ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>&
EpaxosInsReadRsp::_internal_kvs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kvs_;
}
inline ::google::protobuf::RepeatedPtrField<::epxos_instance_proto::EpKeyValueItem>*
EpaxosInsReadRsp::_internal_mutable_kvs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.kvs_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace epxos_instance_proto


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::epxos_instance_proto::EpWorkState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::epxos_instance_proto::EpWorkState>() {
  return ::epxos_instance_proto::EpWorkState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_instance_2eproto_2epb_2eh
